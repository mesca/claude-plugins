---
name: python
description: General Python development guidelines for all Python code. Always apply these conventions when writing, reviewing, or modifying Python code. Covers project structure, imports, typing, style, and tooling.
command: false
---

# Python Guidelines Skill

Foundational Python development conventions that apply to all Python code in this project. These guidelines are always active when working with Python files.

## When to Use This Skill

✅ **Use when:**
- Writing any Python code
- Reviewing Python code
- Refactoring Python modules
- Setting up new Python files or modules
- Any Python-related task

❌ **Don't use when:**
- Working with non-Python files (JavaScript, TypeScript, etc.)

## Project Structure

Use src-layout with layered architecture:

```
${PROJECT_NAME}/
├── pyproject.toml
├── mkdocs.yml              # Documentation config
├── docs/                   # Documentation source
│   ├── index.md
│   ├── reference/          # Auto-generated API docs
│   └── scripts/
│       └── gen_ref_pages.py  # API docs generator
├── src/
│   └── ${PROJECT_NAME}/
│       ├── __init__.py
│       ├── _version.py     # Auto-generated by hatch-vcs
│       ├── core/           # Infrastructure only (logger, config, exceptions)
│       ├── models/         # Data models and schemas
│       ├── services/       # Business logic (framework-agnostic)
│       └── interfaces/     # Entry points
│           ├── cli/        # CLI interface (Typer)
│           └── rest/       # REST API (FastAPI)
└── tests/
    ├── conftest.py
    ├── core/
    ├── models/
    ├── services/
    └── interfaces/
```

### Layer Rules

- **core/**: Infrastructure only - NO business logic
  - `logger.py` - Logging configuration
  - `config.py` - Settings and environment
  - `exceptions.py` - Custom exceptions
  - `utils.py` - Shared utilities

- **services/**: Business logic - framework-agnostic
  - No Typer/FastAPI imports
  - Fully testable without CLI/API
  - Single responsibility per service

- **interfaces/**: Thin wrappers - minimal logic
  - Call services, handle I/O
  - Framework-specific code lives here only

## Python Version

Target Python 3.14+:

```toml
[project]
requires-python = ">=3.14"
```

## Imports

### Import Order

1. Standard library
2. Third-party packages
3. Local imports

```python
import os
from pathlib import Path

import httpx
from pydantic import BaseModel

from ${PROJECT_NAME}.core import logger
from ${PROJECT_NAME}.services.processor import process_data
```

### Import Style

- Prefer `from x import y` for specific items
- Use absolute imports, not relative
- Import modules, not individual functions (when module is small)

```python
# Good
from ${PROJECT_NAME}.core import logger
from ${PROJECT_NAME}.core.config import settings

# Avoid
from ..core import logger  # relative import
from ${PROJECT_NAME}.core.logger import logger, debug, info  # too granular
```

## Type Hints

Always use type hints on all function signatures:

```python
def process_file(
    filepath: Path,
    options: dict[str, Any] | None = None,
) -> ProcessResult:
    """Process a file and return results."""
    ...
```

### Modern Typing (Python 3.14+)

```python
# Use built-in generics
list[str]           # not List[str]
dict[str, int]      # not Dict[str, int]
set[Path]           # not Set[Path]
tuple[int, str]     # not Tuple[int, str]

# Use | for unions
str | None          # not Optional[str]
int | str           # not Union[int, str]

# Use Self for return type
from typing import Self

class Builder:
    def add(self, item: str) -> Self:
        ...
```

## Docstrings

Google-style docstrings for all public functions:

```python
def fetch_data(url: str, timeout: int = 30) -> dict[str, Any]:
    """Fetch data from a URL and return parsed JSON.

    Args:
        url: The URL to fetch data from.
        timeout: Request timeout in seconds. Defaults to 30.

    Returns:
        Parsed JSON response as a dictionary.

    Raises:
        httpx.HTTPError: If the request fails.
        ValueError: If the response is not valid JSON.

    Example:
        >>> data = fetch_data("https://api.example.com/data")
        >>> print(data["status"])
        'ok'
    """
    ...
```

## Logging

**Never use print() - always use logger**

```python
from ${PROJECT_NAME}.core import logger

# Log levels
logger.debug("Processing started")
logger.info(f"Processed {count} items")
logger.success(f"Completed: {result}")
logger.warning(f"Deprecated feature used: {feature}")
logger.error(f"Failed to process: {error}")
logger.critical("System failure - shutting down")

# Log exceptions with context
try:
    process()
except Exception as e:
    logger.error(f"Processing failed: {e}", exc_info=True)
    raise
```

## Error Handling

```python
# Specific exceptions, not bare except
try:
    result = process(data)
except FileNotFoundError:
    logger.error(f"File not found: {filepath}")
    raise
except ValueError as e:
    logger.error(f"Invalid data: {e}")
    raise

# Custom exceptions in core/exceptions.py
class ProcessingError(Exception):
    """Raised when processing fails."""
    pass

# Validate early, fail fast
def process(data: str) -> Result:
    if not data:
        raise ValueError("data cannot be empty")
    if not data.startswith("valid"):
        raise ValueError(f"Invalid data format: {data[:20]}...")
    ...
```

## Constants

Define at module level in ALL_CAPS:

```python
# Good
MAX_RETRIES = 3
DEFAULT_TIMEOUT = 30
SUPPORTED_FORMATS = {"json", "yaml", "toml"}

# Bad
def process():
    max_retries = 3  # magic number
    if timeout > 30:  # magic number
        ...
```

## Configuration

Use environment variables via pydantic-settings:

```python
# core/config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    debug: bool = False
    api_key: str
    database_url: str

    model_config = {"env_prefix": "${PROJECT_NAME}_"}

settings = Settings()
```

```bash
# .env
${PROJECT_NAME}_DEBUG=true
${PROJECT_NAME}_API_KEY=secret
${PROJECT_NAME}_DATABASE_URL=postgresql://...
```

## Tooling

### Package Manager: uv

```bash
uv add package           # Add dependency
uv add --dev pytest      # Add dev dependency
uv run pytest            # Run command
uv sync                  # Sync dependencies
```

### Linting & Formatting: Ruff

```bash
uv run ruff check .      # Lint
uv run ruff format .     # Format
uv run ruff check --fix . # Auto-fix
```

**pyproject.toml**:
```toml
[tool.ruff]
line-length = 88
target-version = "py314"

[tool.ruff.lint]
select = ["E", "W", "F", "I", "B", "S", "C4", "UP", "N", "SIM"]
ignore = ["E501"]

[tool.ruff.lint.per-file-ignores]
"tests/*" = ["S101"]
```

### Type Checking: Pyright

```bash
uv run pyright           # Type check entire project
uv run pyright src/      # Type check specific directory
```

**pyproject.toml**:
```toml
[tool.pyright]
pythonVersion = "3.14"
typeCheckingMode = "strict"
include = ["src"]
exclude = ["**/__pycache__", ".venv"]
reportMissingTypeStubs = false
reportUnknownMemberType = false
```

Run pyright before committing to catch type errors early.

### Build System & Versioning: Hatch

Use hatchling with hatch-vcs for git-based versioning:

**pyproject.toml**:
```toml
[build-system]
requires = ["hatchling", "hatch-vcs"]
build-backend = "hatchling.build"

[tool.hatch.version]
source = "vcs"
fallback-version = "0.0.0+unknown"

[tool.hatch.build.hooks.vcs]
version-file = "src/${PROJECT_NAME}/_version.py"
```

This auto-generates `_version.py` from git tags. Access the version:

```python
from ${PROJECT_NAME}._version import __version__

print(__version__)  # e.g., "1.2.3" or "1.2.3.dev4+gabc1234"
```

#### Bumping Versions

Versions are derived from git tags. To release a new version:

```bash
# Create annotated tag (triggers version bump)
git tag -a v1.0.0 -m "Release 1.0.0"
git push origin v1.0.0

# Or for pre-releases
git tag -a v1.0.0rc1 -m "Release candidate 1"
git tag -a v1.0.0a1 -m "Alpha 1"
git tag -a v1.0.0b1 -m "Beta 1"
```

**Version format from git state**:
| Git State | Version Example |
|-----------|-----------------|
| On tag `v1.2.3` | `1.2.3` |
| 4 commits after `v1.2.3` | `1.2.4.dev4+gabc1234` |
| Uncommitted changes | `1.2.4.dev4+gabc1234.d20240115` |
| No tags yet | `0.0.0+unknown` |

#### Building

```bash
uv build                  # Build sdist and wheel
uv publish                # Publish to PyPI (after configuration)
```

### Testing: pytest

```bash
uv run pytest                    # Run all tests
uv run pytest tests/services/    # Run specific tests
uv run pytest -v --cov           # With coverage
```

### Documentation: Material for MkDocs

```bash
uv run mkdocs serve              # Local dev server with hot reload
uv run mkdocs build --strict     # Build static site
uv run mkdocs gh-deploy --force  # Deploy to GitHub Pages
```

**pyproject.toml**:
```toml
[dependency-groups]
docs = [
    "mkdocs-material>=9.5",
    "mkdocstrings[python]>=0.27",
    "mkdocs-gen-files>=0.5",
    "mkdocs-literate-nav>=0.6",
    "mkdocs-section-index>=0.3",
]

[tool.hatch.envs.docs]
features = ["docs"]

[tool.hatch.envs.docs.scripts]
build = "mkdocs build --strict"
serve = "mkdocs serve"
deploy = "mkdocs gh-deploy --force"
```

See the **documentation skill** for full MkDocs configuration and mkdocstrings setup.

## File Templates

### New Module

```python
"""Module description.

This module provides functionality for...
"""

from ${PROJECT_NAME}.core import logger

__all__ = ["main_function", "MainClass"]


def main_function(arg: str) -> str:
    """Do something with arg.

    Args:
        arg: The input argument.

    Returns:
        Processed result.
    """
    logger.debug(f"Processing: {arg}")
    return arg.upper()


class MainClass:
    """Class description."""

    def __init__(self, value: str) -> None:
        """Initialize with value.

        Args:
            value: Initial value.
        """
        self.value = value
```

### New Test File

```python
"""Tests for module_name."""

import pytest

from ${PROJECT_NAME}.services.module_name import main_function, MainClass


class TestMainFunction:
    """Tests for main_function."""

    def test_returns_uppercase(self) -> None:
        """Test that function returns uppercase."""
        result = main_function("hello")
        assert result == "HELLO"

    def test_raises_on_empty_input(self) -> None:
        """Test that empty input raises ValueError."""
        with pytest.raises(ValueError, match="cannot be empty"):
            main_function("")


class TestMainClass:
    """Tests for MainClass."""

    def test_init_stores_value(self) -> None:
        """Test that init stores the value."""
        obj = MainClass("test")
        assert obj.value == "test"
```

## Quick Reference

| Aspect | Convention |
|--------|------------|
| Python version | 3.14+ |
| Package manager | uv |
| Build system | Hatchling + hatch-vcs |
| Versioning | Git tags (vX.Y.Z) |
| Linter/Formatter | Ruff |
| Type checker | Pyright (strict mode) |
| Test framework | pytest |
| Documentation | Material for MkDocs + mkdocstrings |
| Docstring style | Google |
| Type hints | Required on all functions |
| Logging | loguru (via `${PROJECT_NAME}.core`) |
| REST API | FastAPI + uvicorn |
| Simple websites | FastAPI + Jinja2 + HTMX |
| CLI | Typer |
| Print statements | Never (use logger) |
| Line length | 88 |
| Import style | Absolute, sorted |

## Output Format

When applying these Python guidelines, report:

1. Files modified with conventions applied
2. Imports reorganized
3. Type hints added/corrected
4. Docstrings added/updated
5. Linting/formatting results

## See Also

- **project-name** - Resolves `${PROJECT_NAME}` variable
- **logging** - Detailed logging patterns and configuration
- **code-quality** - Code review checklist and refactoring
- **documentation** - Full MkDocs setup and docstring examples
- **tdd** - Test-driven development with pytest
- **performance** - Optimization patterns
- **security** - Security best practices
